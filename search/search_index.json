{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-spawndevblazorjs-docs","title":"Welcome to SpawnDev.BlazorJS Docs","text":"<p>The primary purpose of SpawnDev.BlazorJS and related libraries it to give Blazor WASM access to everything Javascript has access to by writing C#, not Javascript.</p> <p>WebAssembly lacks some abilities that Javascript has, such access to the DOM, and a growing number of APIs. SpawnDev.BlazorJS gives Blazor WASM strongly typed access to those browser features via custom Javascript interop.</p> <p>WebRTC, IndexedDB, canvas contexts, Geolocation, Push APIs... Anything Javascript has access to is accessible in Blazor WASM with SpawnDev.BlazorJS.  </p> <p>Run your Blazor WASM in DedicatedWorkers, SharedWorkers, and even ServiceWorkers with SpawnDev.BlazorJS.WebWorkers. Use WebWorkers to run services in another thread. Handle ServiceWorker events in .Net with a ServiceWorkerEventHandler.</p>"},{"location":"#nuget","title":"NuGet","text":"Package Description SpawnDev.BlazorJS Enhanced Blazor WebAssembly Javascript interop SpawnDev.BlazorJS.WebWorkers Blazor WASM WebWorkers, SharedWebWorkers, and ServiceWorker"},{"location":"about/","title":"Hola","text":""},{"location":"blazorjs/BlazorJSRuntime/","title":"BlazorJSRuntime","text":""},{"location":"blazorjs/BlazorJSRuntime/#add-nuget","title":"Add Nuget","text":""},{"location":"blazorjs/BlazorJSRuntime/#example-programcs","title":"Example Program.cs.","text":"<ul> <li>Add the BlazorJSRuntime service with builder.Services.AddBlazorJSRuntime()</li> <li>Initialize BlazorJSRuntime by calling BlazorJSRunAsync() instead of RunAsync()</li> </ul> <pre><code>...\nusing SpawnDev.BlazorJS;\n\nvar builder = WebAssemblyHostBuilder.CreateDefault(args);\n// add SpawnDev.BlazorJS.BlazorJSRuntime\nbuilder.Services.AddBlazorJSRuntime();\n// other services ...\n// build and Init using BlazorJSRunAsync (instead of RunAsync)\nawait builder.Build().BlazorJSRunAsync();\n</code></pre> <p>BlazorJSRunAsync() is a scope aware replacement for RunAsync(). It provides a few features that are required by some SpawnDev services, including auto starting services that request it, and preventing Blazor from trying to render components when not running in the window scope.</p>"},{"location":"blazorjs/BlazorJSRuntime/#inject-into-components","title":"Inject into components","text":"<pre><code>[Inject]\nBlazorJSRuntime JS { get; set; }\n</code></pre> <p>Examples <pre><code>// Get and Set\nvar innerHeight = JS.Get&lt;int&gt;(\"window.innerHeight\");\nJS.Set(\"document.title\", \"Hello World!\");\n\n// Call\nvar item = JS.Call&lt;string?&gt;(\"localStorage.getItem\", \"itemName\");\nJS.CallVoid(\"addEventListener\", \"resize\", Callback.Create(() =&gt; Console.WriteLine(\"WindowResized\"), _callBacks));\n\n// Attach events\nusing var window = JS.Get&lt;Window&gt;(\"window\");\nwindow.OnOffline += Window_OnOffline;\n</code></pre></p>"},{"location":"blazorjs/BlazorJSRuntime/#important-note-async-vs-sync-javascript-calls","title":"IMPORTANT NOTE - Async vs Sync Javascript calls","text":"<p>The BlazorJSRuntime behaves differently than the default Blazor JSRuntime. BlazorJSRuntime is more of a 1 to 1 mapping to Javascript. </p> <p>When calling Javascript methods that are not asynchronous and do not return a Promise you need to use the synchronous BlazorJSRuntime methods Call, CallVoid, or Get.  Unlike the default Blazor JSRuntime which would allow the use of InvokeAsync, you must use the synchronous BlazorJSRuntime methods.</p> <p>Use synchronous BlazorJSRuntime calls for synchronous Javascrtipt methods.  BlazorJSRuntime CallAsync would throw an error if used on the below Javascript method.</p> <pre><code>// Javascript\nfunction AddNum(num1, num2){\n    return num1 + num2;\n}\n</code></pre> <pre><code>// C#\nvar total = JS.Call&lt;int&gt;(\"AddNum\", 20, 22);\n// total == 42 here\n</code></pre> <p>Use asynchronous BlazorJSRuntime calls for asynchronous Javascript methods. <pre><code>// Javascript\nasync function AddNum(num1, num2){\n    return num1 + num2;\n}\n</code></pre></p> <pre><code>// C#\nvar total = await JS.CallAsync&lt;int&gt;(\"AddNum\", 20, 22);\n// total == 42 here\n</code></pre> <p>Use asynchronous BlazorJSRuntime calls for methods that return a Promise. <pre><code>// Javascript\nfunction AddNum(num1, num2){\n    return new Promise((resolve, reject)=&gt;{\n        resolve(num1 + num2);\n    });\n}\n</code></pre></p> <pre><code>// C#\nvar total = await JS.CallAsync&lt;int&gt;(\"AddNum\", 20, 22);\n// total == 42 here\n</code></pre>"},{"location":"blazorjs/Callback/","title":"Callback","text":"<p>The Callback class is used to support Action and Func serialization. Callback.Create and Callback.CreateOne are shortcut methods for creating ActionCallback, FuncCallback, AsyncActionCallback, and AsyncFuncCallback.</p> <p>Pass lambda callbacks to Javascript <pre><code>JS.Set(\"testCallback\", Callback.Create&lt;string&gt;((strArg) =&gt; {\n    Console.WriteLine($\"Javascript sent: {strArg}\");\n    // this prints \"Hello callback!\"\n}));\n</code></pre> <pre><code>// in Javascript\ntestCallback('Hello callback!');\n</code></pre></p> <p>Pass method callbacks to Javascript <pre><code>string SomeNetFn(string input){\n    return $\"Recvd: {input}\";\n}\n\nJS.Set(\"someNetFn\", Callback.CreateOne&lt;string, string&gt;(SomeNetFn));\n</code></pre> <pre><code>// in Javascript\nsomeNetFn('Hello callback!');\n\n// prints\nRecvd: Hello callback!\n</code></pre></p> <p>Pass async method callbacks to Javascript Under the hood, BlazorJS is returning a Promise to Javascript when the method is called</p> <p><pre><code>async Task&lt;string&gt; SomeNetFnAsync(string input){\n    return $\"Recvd: {input}\";\n}\n\nJS.Set(\"someNetFnAsync\", Callback.CreateOne&lt;string, string&gt;(SomeNetFnAsync));\n</code></pre> <pre><code>// in Javascript\nawait someNetFnAsync('Hello callback!');\n\n// prints\nRecvd: Hello callback!\n</code></pre></p>"},{"location":"blazorjs/IJSInProcessObjectReference/","title":"IJSInProcessObjectReference extended","text":"<p>IJSInProcessObjectReference extensions methods have been added to aid in Javascript interop. JSObject wrapped Javascript objects use the extended IJSInProcessObjectReference reference internally. </p>"},{"location":"blazorjs/IJSInProcessObjectReference/#ijsinprocessobjectreference-extended-methods","title":"IJSInProcessObjectReference extended methods:","text":"<p>\"identifier\", aka property key, can be any type because that is what Javascript allows. - CallVoid(object identifier, arg0, ...) - Call(object identifier, arg0, ...) - CallAsync(object identifier, arg0, ...) - CallVoidAsync(object identifier, arg0, ...) - Get(object identifier) - GetAsync(object identifier) - Set(object identifier, object? value) <pre><code>// Get Set\nvar window = JS.Get&lt;IJSInProcessObjectReference&gt;(\"window\");\nwindow.Set(\"myVar\", 5);\nvar myVar = window.Get&lt;int&gt;(\"myVar\");\n\n// Synchronous calls\nwindow.CallVoid(\"addEventListener\", \"resize\", Callback.Create(() =&gt; Console.WriteLine(\"WindowResized\")));\n</code></pre> <p>Create a new Javascript object using the BlazorJSRuntime (JS) <pre><code>IJSInProcessObjectReference worker = JS.New(\"Worker\", myWorkerScript);\n</code></pre></p>"},{"location":"blazorjs/IJSObject/","title":"IJSObject Interface","text":"<p>SpawnDev.BlazorJS can now wrap Javascript objects using interfaces. Just like objects derived from the JSObject class, IJSObject interfaces internally use IJSInProcessObjectReference to wrap a Javascript object for direct manipulation and can be passed to and from Javascript. The main difference is IJSObjects use DispatchProxy to implement the desired interface at runtime instead of requiring a type that inherits JSObject. Currently SpawnDev.BlazorJS does not provide any interfaces for Javascript objects or apis but interfaces are simple to set up.</p> <p>IJSObject Example <pre><code>// create an interface for your Javascript object that implements IJSObject\npublic interface IWindow : IJSObject \n{\n    string Name { get; set; }\n    void Alert(string msg = \"\");\n    // ...\n}\n\n// use your IJSObject interface to interact with the Javascript object\npublic void IJSObjectInterfaceTest() {\n    var w = JS.Get&lt;IWindow&gt;(\"window\");\n    var randName = Guid.NewGuid().ToString();\n    // directly set the window.name property\n    w.Name = randName;\n    // verify the read back\n    if (w.Name != randName) throw new Exception(\"Interface property set/get failed\");\n}\n</code></pre></p>"},{"location":"blazorjs/JSEventCallback/","title":"JSEventCallback","text":"<p>Now used extensively throughout the JSObject collection, JSEventCallback allows a clean .Net style way to add and remove .Net callbacks for Javascript events.</p> <p>With JSEventCallback the operands += and -= can be used to attach and detach .Net callbacks to Javascript events. All reference handling is done automatically when events are added and removed.</p> <p>Example taken from the Window JSObject class which inherits from EventTarget. JSEventCallback handles creating and disposing of the Callback object passed to Javascript. <pre><code>public class Window : EventTarget\n{\n    ...\n    // This is how JSEventCallback is implemented in the Window class\n    public JSEventCallback&lt;StorageEvent&gt; OnStorage { get =&gt; new JSEventCallback&lt;StorageEvent&gt;(o =&gt; AddEventListener(\"storage\", o), o =&gt; RemoveEventListener(\"storage\", o)); set { /** set MUST BE HERE TO ENABLE += -= operands **/ } }\n    ...\n}\n</code></pre></p> <p>Example event attach, detach, and handler <pre><code>void AttachEventHandlersExample()\n{\n    using var window = JS.Get&lt;Window&gt;(\"window\");\n    // If this is the first time Window_OnStorage has been attached to an event a .Net reference is automatically created and held for future use and removal\n    window.OnStorage += Window_OnStorage;\n    // the window JSObject reference can safely be disposed as the .Net reference is attached to Window_OnStorage internally\n}\nvoid DetachEventHandlersExample()\n{\n    using var window = JS.Get&lt;Window&gt;(\"window\");\n    // If this is the last reference of Window_OnStorage being removed then the .Net reference will automatically be disposed.\n    // IMPORTANT - detaching is important for preventing resource leaks. .Net references are only released when the reference count reaches zero (same number of -= as += used)\n    window.OnStorage -= Window_OnStorage;\n}\nvoid Window_OnStorage(StorageEvent storageEvent)\n{\n    Console.WriteLine($\"StorageEvent: {storageEvent.Key} has changed\");\n}\n</code></pre></p>"},{"location":"blazorjs/Undefinable/","title":"Undefinable","text":"<p>Use Undefinable\\&lt;T&gt; type to pass undefined to Javascript  </p> <p>Some Javascript API calls may have optional parameters that behave differently depending on if you pass a null versus undefined. You can now retain strong typing on JSObject method calls and support passing undefined for JSObject parameters.</p> <p>New Undefinable\\&lt;T&gt; type. </p> <p>Example from Test app unit tests <pre><code>// an example method with a parameter that can also be null or undefined\n// T of Undefinable&lt;T&gt; must be nullable\nvoid MethodWithUndefinableParams(string varName, Undefinable&lt;bool?&gt;? window)\n{\n    JS.Set(varName, window);\n}\n\nbool? w = false;\n// test to show the value is passed normally\nMethodWithUndefinableParams(\"_willBeDefined2\", w);\nbool? r = JS.Get&lt;bool?&gt;(\"_willBeDefined2\");\nif (r != w) throw new Exception(\"Unexpected result\");\n\nw = null;\n// null defaults to passing as undefined\nMethodWithUndefinableParams(\"_willBeUndefined2\", w);\nif (!JS.IsUndefined(\"_willBeUndefined2\")) throw new Exception(\"Unexpected result\");\n\n// if you need to pass null to an Undefinable parameter use Undefinable&lt;T?&gt;.Null\nMethodWithUndefinableParams(\"_willBeNull2\", Undefinable&lt;bool?&gt;.Null);\nif (JS.IsUndefined(\"_willBeNull2\")) throw new Exception(\"Unexpected result\");\n\n// another way to pass undefined\nMethodWithUndefinableParams(\"_willAlsoBeUndefined2\", Undefinable&lt;bool?&gt;.Undefined);\nif (!JS.IsUndefined(\"_willAlsoBeUndefined2\")) throw new Exception(\"Unexpected result\");\n</code></pre></p> <p>If using JSObjects you can also use JSObject.Undefined\\&lt;T&gt; to create an instance that will be passed to Javascript as undefined.</p> <pre><code>// Create an instance of the Window JSObject class that is revived in Javascript as undefined\nvar undefinedWindow = JSObject.Undefined&lt;Window&gt;();\n// undefinedWindow is an instance of Window that is revived in Javascript as undefined\nJS.Set(\"_undefinedWindow\", undefinedWindow);\nvar isUndefined = JS.IsUndefined(\"_undefinedWindow\");\n// isUndefined == true here\n</code></pre>"},{"location":"blazorjs/Union/","title":"Union","text":"<p>Use the Union&lt;T1, T2, ...&gt; type with method parameters for strong typing while allowing unrelated types just like in TypeScript.</p> <pre><code>void UnionTypeTestMethod(string varName, Union&lt;bool?, string?&gt;? unionTypeValue)\n{\n    JS.Set(varName, unionTypeValue);\n}\n\nvar stringValue = \"Hello world!\";\nUnionTypeTestMethod(\"_stringUnionValue\", stringValue);\nif (stringValue != JS.Get&lt;string?&gt;(\"_stringUnionValue\")) throw new Exception(\"Unexpected result\");\n\nvar boolValue = true;\nUnionTypeTestMethod(\"_boolUnionValue\", boolValue);\nif (boolValue != JS.Get&lt;bool?&gt;(\"_boolUnionValue\")) throw new Exception(\"Unexpected result\");\n</code></pre>"},{"location":"blazorjs/intro/","title":"SpawnDev.BlazorJS","text":"<p>The primary purpose of BlazorJS is to allow working with Javascript in Blazor WASM by writing C# not Javascript. Full Blazor WebAssembly and Javascript interop. Access properties, methods, events, and constructors of Javascript objects with Blazor WASM without writing Javascript.</p>"},{"location":"blazorjs/intro/#primary-parts-of-spawndevblazorjs","title":"Primary parts of SpawnDev.BlazorJS","text":"<ul> <li>BLazorJSRuntime service - The core of BlazorJS, BLazorJSRuntime is a JSRuntime alternative designed to make working with Javascript as straightforward as possible.</li> <li>JSObject - JSObject is an alternative to IJSObjectReference and IJSInProcessObjectReference that, when inherited, allows wrapping a Javascript object for use in Blazor WASM with full access to properties, methods, events, and constructors.</li> <li>Callback - Callback is used to pass .Net methods to Javascript.</li> </ul>"},{"location":"blazorjs/intro/#supported-net-versions","title":"Supported .Net Versions","text":"<ul> <li>Blazor WebAssembly .Net 6, 7, and 8 </li> <li> <ul> <li>Tested VS Template: Blazor WebAssembly Standalone App</li> </ul> </li> <li>Blazor United .Net 8 (in WebAssembly project only) </li> <li> <ul> <li>Tested VS Template: Blazor Web App (Auto or WebAssembly interactive mode)</li> </ul> </li> </ul>"},{"location":"blazorjs/intro/#features","title":"Features","text":"<ul> <li>260+ strongly typed JSObject wrappers (listed here) included in BlazorJS including DOM, Crypto, WebGL, WebRTC, and Promises allow direct interaction with Javascript</li> <li>Use Javascript libraries in Blazor without writing any Javascript code</li> <li>BlazorJSRuntime wraps the default JSRuntime adding additional functionality</li> <li>Create new Javascript objects directly from Blazor</li> <li>Get and set Javascript object properties as well as access methods</li> <li>Easily pass .Net methods to Javascript using JSEventCallback, Callback.Create or Callback.CreateOne methods</li> <li>2 options for wrapping your Javascript objects for direct manipulation from Blazor (No javascript required!)</li> <li> <ul> <li>Create a class that inherits JSObject and defines the methods, properties, events, and constructors of your Javascript object (best option)</li> </ul> </li> <li> <ul> <li>Create an interface that implements IJSObject and defines the methods and properties of your Javascript object (more limited than JSObject option)</li> </ul> </li> <li>Use SpawnDev.BlazorJS.WebWorkers to enable calling Blazor services in SharedWorkers and DedicatedWorkers</li> <li>Run Blazor WASM in ServiceWorkers to handle ServiceWorker events in .Net</li> <li>Supports Promises, Union method parameters, passing undefined to Javascript, and more</li> </ul>"},{"location":"blazorjs/intro/#issues-and-feature-requests","title":"Issues and Feature requests","text":"<p>If you find a bug or missing properties, methods, or Javascript objects please submit an issue here on GitHub. I will help as soon as possible.</p>"},{"location":"blazorjs/JSObject/JSObject/","title":"JSObject Base Class","text":"<p>JSObjects are wrappers around IJSInProcessReference objects that can be passed to and from Javascript and allow strongly typed access to the underlying object. </p> <p>Over 200 strongly typed, .Net ready Javascript objects are included in SpawnDev.BlazorJS to get you started. JSObject wrappers are easy to make and we are adding wrappers for libraries often. (Look for other SpawnDev.BlazorJS Nuget packages. Request a wrapper by opening an issue on our GitHub repo.)</p> <p>JSObject type wrapper example <pre><code>// create a class for your Javascript object that inherits from JSObject\npublic class Window : EventTarget \n{\n    // required constructor\n    public Window(IJSInProcessObjectReference _ref) : base(_ref) { }\n    public string Name { get =&gt; JSRef.Get&lt;string&gt;(\"name\"); set =&gt; JSRef.Set(\"name\", value); }\n    public void Alert(string msg = \"\") =&gt; JSRef.CallVoid(msg);\n    // ...\n}\n\n// use the JSObject class to interact with the Javascript object\npublic void JSObjectClassTest() {\n    var w = JS.Get&lt;Window&gt;(\"window\");\n    var randName = Guid.NewGuid().ToString();\n    // directly set the window.name property\n    w.Name = randName;\n    // verify the read back\n    if (w.Name != randName) throw new Exception(\"Interface property set/get failed\");\n}\n</code></pre></p> <p>Use the extended functions of IJSInProcessObjectReference to work with Javascript objects or use the growing library of over 100 of the most common Javascript objects, including ones for Window, HTMLDocument, Storage (localStorage and sessionStorage), WebGL, WebRTC, and more in SpawnDev.BlazorJS.JSObjects. JSObjects are wrappers around IJSInProcessObjectReference that allow strongly typed use.</p> <p>Below shows a section of the SpawnDev.BlazorJS.JSObjects.Window class. Window's base type, EventTarget, inherits from JSObject. <pre><code>public class Window : EventTarget {\n    // all JSObject types must have this constructor\n    public Window(IJSInProcessObjectReference _ref) : base(_ref) { }\n    // here is a property with both getter and setter\n    public string? Name { get =&gt; JSRef.Get&lt;string&gt;(\"name\"); set =&gt; JSRef.Set(\"name\", value); }\n    // here is a read only property that returns another JSObject type\n    public Storage LocalStorage =&gt; JSRef.Get&lt;Storage&gt;(\"localStorage\");\n    // here are methods\n    public long SetTimeout(Callback callback, double delay) =&gt; JSRef.Call&lt;long&gt;(\"setTimeout\", callback, delay);\n    public void ClearTimeout(long requestId) =&gt; JSRef.CallVoid(\"clearTimeout\", requestId);    \n    // ... \n}\n</code></pre></p> <p>Below the JSObject derived Window class is used <pre><code>// below the JSObject derived Window class is used\nusing var window = JS.Get&lt;Window&gt;(\"window\");\nvar randName = Guid.NewGuid().ToString();\n// set and get properties\nwindow.Name = randName;\nvar name = window.Name;\n// call methods\nwindow.Alert(\"Hello!\");\n</code></pre></p>"},{"location":"blazorjs/JSObject/JSObject/#custom-jsobjects","title":"Custom JSObjects","text":"<p>Implement your own JSObject classes for Javascript objects not already available in the BlazorJS.JSObjects library.</p> <p>Instead of this (simple but not as reusable) <pre><code>var audio = JS.New(\"Audio\", \"https://some_audio_online\");\naudio.CallVoid(\"play\");\n</code></pre> You can do this... Create a custom JSObject wrapper <pre><code>public class Audio : JSObject\n{\n    public Audio(IJSInProcessObjectReference _ref) : base(_ref) { }\n    public Audio(string url) : base(JS.New(\"Audio\", url)) { }\n    public void Play() =&gt; JSRef.CallVoid(\"play\");\n}\n</code></pre></p> <p>Then use your new object <pre><code>var audio = new Audio(\"https://some_audio_online\");\naudio.Play();\n</code></pre></p>"},{"location":"blazorjs-webworkers/ServiceWorker/","title":"ServiceWorker","text":"<p>As of version 2.2.21 SpawnDev.BlazorJS.WebWorkers supports running Blazor WASM apps in ServiceWorkers. Your app can now register a class to run in the ServiceWorker to handle ServiceWorker events.</p>"},{"location":"blazorjs-webworkers/ServiceWorker/#wwwrootservice-workerjs","title":"wwwroot/service-worker.js","text":"<p>Create or modify to match the line below. <pre><code>importScripts('_content/SpawnDev.BlazorJS.WebWorkers/spawndev.blazorjs.webworkers.js');\n</code></pre></p>"},{"location":"blazorjs-webworkers/ServiceWorker/#programcs","title":"Program.cs","text":"<p>A minimal Program.cs <pre><code>var builder = WebAssemblyHostBuilder.CreateDefault(args);\nbuilder.RootComponents.Add&lt;App&gt;(\"#app\");\nbuilder.RootComponents.Add&lt;HeadOutlet&gt;(\"head::after\");\n// SpawnDev.BlazorJS\nbuilder.Services.AddBlazorJSRuntime();\n// SpawnDev.BlazorJS.WebWorkers\nbuilder.Services.AddWebWorkerService();\n// Register a ServiceWorker handler (AppServiceWorker here) that inherits from ServiceWorkerEventHandler\nbuilder.Services.RegisterServiceWorker&lt;AppServiceWorker&gt;();\n// Or Unregister the ServiceWorker if no longer desired\n//builder.Services.UnregisterServiceWorker();\n// SpawnDev.BlazorJS startup (replaces RunAsync())\nawait builder.Build().BlazorJSRunAsync();\n</code></pre></p>"},{"location":"blazorjs-webworkers/ServiceWorker/#appserviceworkercs","title":"AppServiceWorker.cs","text":"<p>A verbose service worker implementation example. - Handle ServiceWorker events by overriding the ServiceWorkerEventHandler base class virtual methods. - The ServiceWorker event handlers are only called when running in a ServiceWorkerGlobalScope context. - The AppServiceWorker singleton may be started in any scope and therefore must be scope aware. (For example, do not try to use localStorage in a Worker scope.) <pre><code>public class AppServiceWorker : ServiceWorkerEventHandler\n{\n    public AppServiceWorker(BlazorJSRuntime js, ServiceWorkerConfig serviceWorkerConfig) : base(js, serviceWorkerConfig)\n    {\n\n    }\n\n    // called before any ServiceWorker events are handled\n    protected override async Task OnInitializedAsync()\n    {\n        // This service may start in any scope. This will be called before the app runs.\n        // If JS.IsWindow == true be careful not stall here.\n        // you can do initialization based on the scope that is running\n        Log(\"GlobalThisTypeName\", JS.GlobalThisTypeName);\n    }\n\n    protected override async Task ServiceWorker_OnInstallAsync(ExtendableEvent e)\n    {\n        Log($\"ServiceWorker_OnInstallAsync\");\n        _ = ServiceWorkerThis!.SkipWaiting();   // returned task can be ignored\n    }\n\n    protected override async Task ServiceWorker_OnActivateAsync(ExtendableEvent e)\n    {\n        Log($\"ServiceWorker_OnActivateAsync\");\n        await ServiceWorkerThis!.Clients.Claim();\n    }\n\n    protected override async Task&lt;Response&gt; ServiceWorker_OnFetchAsync(FetchEvent e)\n    {\n        Log($\"ServiceWorker_OnFetchAsync\", e.Request.Method, e.Request.Url);\n        Response ret;\n        try\n        {\n            ret = await JS.Fetch(e.Request);\n        }\n        catch (Exception ex)\n        {\n            ret = new Response(ex.Message, new ResponseOptions { Status = 500, StatusText = ex.Message, Headers = new Dictionary&lt;string, string&gt; { { \"Content-Type\", \"text/plain\" } } });\n            Log($\"ServiceWorker_OnFetchAsync failed: {ex.Message}\");\n        }\n        return ret;\n    }\n\n    protected override async Task ServiceWorker_OnMessageAsync(ExtendableMessageEvent e)\n    {\n        Log($\"ServiceWorker_OnMessageAsync\");\n    }\n\n    protected override async Task ServiceWorker_OnPushAsync(PushEvent e)\n    {\n        Log($\"ServiceWorker_OnPushAsync\");\n    }\n\n    protected override void ServiceWorker_OnPushSubscriptionChange(Event e)\n    {\n        Log($\"ServiceWorker_OnPushSubscriptionChange\");\n    }\n\n    protected override async Task ServiceWorker_OnSyncAsync(SyncEvent e)\n    {\n        Log($\"ServiceWorker_OnSyncAsync\");\n    }\n\n    protected override async Task ServiceWorker_OnNotificationCloseAsync(NotificationEvent e)\n    {\n        Log($\"ServiceWorker_OnNotificationCloseAsync\");\n    }\n\n    protected override async Task ServiceWorker_OnNotificationClickAsync(NotificationEvent e)\n    {\n        Log($\"ServiceWorker_OnNotificationClickAsync\");\n    }\n}\n</code></pre></p>"},{"location":"blazorjs-webworkers/WebWorkers/","title":"WebWorkers","text":""},{"location":"blazorjs-webworkers/WebWorkers/#add-nuget","title":"Add Nuget","text":""},{"location":"blazorjs-webworkers/WebWorkers/#example-programcs","title":"Example Program.cs","text":"<pre><code>...\nusing SpawnDev.BlazorJS;\nusing SpawnDev.BlazorJS.WebWorkers;\n\nvar builder = WebAssemblyHostBuilder.CreateDefault(args);\nbuilder.RootComponents.Add&lt;App&gt;(\"#app\");\nbuilder.RootComponents.Add&lt;HeadOutlet&gt;(\"head::after\");\n// Add SpawnDev.BlazorJS.BlazorJSRuntime\nbuilder.Services.AddBlazorJSRuntime();\n// Add SpawnDev.BlazorJS.WebWorkers.WebWorkerService\nbuilder.Services.AddWebWorkerService();\n// Add app services that will be called on the main thread and/or worker threads (Worker services must use interfaces)\nbuilder.Services.AddSingleton&lt;IFaceAPIService, FaceAPIService&gt;();\nbuilder.Services.AddSingleton&lt;IMathsService, MathsService&gt;();\n// More app services\n// ...\n// build and Init using BlazorJSRunAsync (instead of RunAsync)\nawait builder.Build().BlazorJSRunAsync();\n</code></pre>"},{"location":"blazorjs-webworkers/WebWorkers/#webworker","title":"WebWorker","text":"<p>You can use the WebWorkerService properties <code>SharedWebWorkerSupported</code> and <code>WebWorkerSupported</code> to check for support.</p> <p>Example component code that uses the service IMyService in a WebWorker if supported and falls back to the Window scoped IMyService if not supported. <pre><code>[Inject]\nWebWorkerService workerService { get; set; }\n\n[Inject]\nIServiceProvider serviceProvider { get; set; }\n\n// MyServiceAuto will be IMyService running in the WebWorker context if available and IMyService running in the Window context if not\nIMyService MyService { get; set; }\n\nWebWorker? webWorker { get; set; }\n\nprotected override async Task OnInitializedAsync()\n{\n    // GetWebWorker() will return null if workerService.WebWorkerSupported == false\n    webWorker = await workerService.GetWebWorker();\n    // get the WebWorker's service instance if available or this Window's service instance if not\n    MyService = webWorker != null ? webWorker.GetService&lt;IMyService&gt;() : serviceProvider.GetService&lt;IMyService&gt;();\n    await base.OnInitializedAsync();\n}\n</code></pre></p> <p>Another example with a progress callback. <pre><code>// Create a WebWorker\n\n[Inject]\nWebWorkerService workerService { get; set; }\n\n // ...\n\nvar webWorker = await workerService.GetWebWorker();\n\n// Call GetService&lt;ServiceInterface&gt; on a web worker to get a proxy for the service on the web worker.\n// GetService can only be called with Interface types\nvar workerMathService = webWorker.GetService&lt;IMathsService&gt;();\n\n// Call async methods on your worker service \nvar result = await workerMathService.CalculatePi(piDecimalPlaces);\n\n// Action types can be passed for progress reporting\nvar result = await workerMathService.CalculatePiWithActionProgress(piDecimalPlaces, new Action&lt;int&gt;((i) =&gt;\n{\n    // the worker thread can call this method to report progress if desired\n    piProgress = i;\n    StateHasChanged();\n}));\n</code></pre></p>"},{"location":"blazorjs-webworkers/WebWorkers/#sharedwebworker","title":"SharedWebWorker","text":"<p>Calling GetSharedWebWorker in another window with the same sharedWorkerName will return the same SharedWebWorker <pre><code>// Create or get SHaredWebWorker with the provided sharedWorkerName\nvar sharedWebWorker = await workerService.GetSharedWebWorker(\"workername\");\n\n// Just like WebWorker but shared\nvar workerMathService = sharedWebWorker.GetService&lt;IMathsService&gt;();\n\n// Call async methods on your shared worker service\nvar result = await workerMathService.CalculatePi(piDecimalPlaces);\n</code></pre></p>"},{"location":"blazorjs-webworkers/WebWorkers/#send-events","title":"Send events","text":"<pre><code>// Optionally listen for event messages\nworker.OnMessage += (sender, msg) =&gt;\n{\n    if (msg.TargetName == \"progress\")\n    {\n        PiProgress msgData = msg.GetData&lt;PiProgress&gt;();\n        piProgress = msgData.Progress;\n        StateHasChanged();\n    }\n};\n\n// From SharedWebWorker or WebWorker threads send an event to connected parents\nworkerService.SendEventToParents(\"progress\", new PiProgress { Progress = piProgress });\n\n// Or on send an event to a connected worker\nwebWorker.SendEvent(\"progress\", new PiProgress { Progress = piProgress });\n</code></pre>"},{"location":"blazorjs-webworkers/WebWorkers/#worker-transferable-jsobjects","title":"Worker Transferable JSObjects","text":"<p>Faster is better. SpawnDev WebWorkers use transferable objects by default for better performance, but it can be disabled with WorkerTransferAttribute. Setting WorkerTransfer to false will cause the property, return value, or parameter to be copied to the receiving thread instead of transferred.</p> <p>Example <pre><code>public class ProcessFrameResult : IDisposable\n{\n    [WorkerTransfer(false)]\n    public ArrayBuffer? ArrayBuffer { get; set; }\n    public byte[]? HomographyBytes { get; set; }\n    public void Dispose(){\n        ArrayBuffer?.Dispose();\n    }\n}\n\n[return: WorkerTransfer(false)]\npublic async Task&lt;ProcessFrameResult?&gt; ProcessFrame([WorkerTransfer(false)] ArrayBuffer? frameBuffer, int width, int height, int _canny0, int _canny1, double _needlePatternSize)\n{\n    var ret = new ProcessFrameResult();\n    // ...\n    return ret;\n}\n</code></pre></p> <p>In the above example; the WorkerTransferAttribute on the return type set to false will prevent all properties of the return type from being transferred.</p>"},{"location":"blazorjs-webworkers/WebWorkers/#transferable-jsobject-types-source-mdn","title":"Transferable JSObject types. Source MDN","text":"<p>ArrayBuffer MessagePort ReadableStream WritableStream TransformStream AudioData ImageBitmap VideoFrame OffscreenCanvas RTCDataChannel  </p>"},{"location":"blazorjs-webworkers/intro/","title":"SpawnDev.BlazorJS.WebWorkers","text":"<ul> <li> <p>Supports Blazor WASM .Net 6, 7, and 8.</p> </li> <li> <p>Easily call Blazor Services in separate threads with WebWorkers and SharedWebWorkers </p> </li> <li> <p>Does not require SharedArrayBuffer and therefore does not require the special HTTP headers associated with using it.</p> </li> <li> <p>Supports and uses transferable objects whenever possible</p> </li> <li> <p>Run Blazor WASM in a Service Worker</p> </li> </ul> <p>Tested working in the following browsers (tested with .Net 8.) Chrome Android does not currently support SharedWorkers. </p> Browser WebWorker Status SharedWebWorker Status Chrome \u2714 \u2714 MS Edge \u2714 \u2714 Firefox \u2714 \u2714 Chrome Android \u2714 \u274c (SharedWorker not supported by browser) MS Edge Android \u2714 \u274c (SharedWorker not supported by browser) Firefox Android \u2714 \u2714 <p>Firefox WebWorkers note: Firefox does not support dynamic modules in workers, which originally made BlazorJS.WebWorkers fail in that browser. The web worker script now tries to detect this and changes the blazor wasm scripts before they are loaded to workaround this limitation. It is possible some other browsers may have this issue but may not be detected properly.</p> <p>Issues can be reported here on GitHub.</p>"}]}